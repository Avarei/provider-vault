/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AllowedUserKeyConfigObservation struct {

	// List of allowed key lengths, vault-1.10 and above
	Lengths []*float64 `json:"lengths,omitempty" tf:"lengths,omitempty"`

	// Key type, choices:
	// rsa, ecdsa, ec, dsa, ed25519, ssh-rsa, ssh-dss, ssh-ed25519, ecdsa-sha2-nistp256, ecdsa-sha2-nistp384, ecdsa-sha2-nistp521
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type AllowedUserKeyConfigParameters struct {

	// List of allowed key lengths, vault-1.10 and above
	// +kubebuilder:validation:Required
	Lengths []*float64 `json:"lengths" tf:"lengths,omitempty"`

	// Key type, choices:
	// rsa, ecdsa, ec, dsa, ed25519, ssh-rsa, ssh-dss, ssh-ed25519, ecdsa-sha2-nistp256, ecdsa-sha2-nistp384, ecdsa-sha2-nistp521
	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type SecretBackendRoleObservation struct {
	AlgorithmSigner *string `json:"algorithmSigner,omitempty" tf:"algorithm_signer,omitempty"`

	AllowBareDomains *bool `json:"allowBareDomains,omitempty" tf:"allow_bare_domains,omitempty"`

	AllowHostCertificates *bool `json:"allowHostCertificates,omitempty" tf:"allow_host_certificates,omitempty"`

	AllowSubdomains *bool `json:"allowSubdomains,omitempty" tf:"allow_subdomains,omitempty"`

	AllowUserCertificates *bool `json:"allowUserCertificates,omitempty" tf:"allow_user_certificates,omitempty"`

	AllowUserKeyIds *bool `json:"allowUserKeyIds,omitempty" tf:"allow_user_key_ids,omitempty"`

	AllowedCriticalOptions *string `json:"allowedCriticalOptions,omitempty" tf:"allowed_critical_options,omitempty"`

	AllowedDomains *string `json:"allowedDomains,omitempty" tf:"allowed_domains,omitempty"`

	AllowedExtensions *string `json:"allowedExtensions,omitempty" tf:"allowed_extensions,omitempty"`

	// Set of allowed public key types and their relevant configuration
	AllowedUserKeyConfig []AllowedUserKeyConfigObservation `json:"allowedUserKeyConfig,omitempty" tf:"allowed_user_key_config,omitempty"`

	AllowedUserKeyLengths map[string]*float64 `json:"allowedUserKeyLengths,omitempty" tf:"allowed_user_key_lengths,omitempty"`

	AllowedUsers *string `json:"allowedUsers,omitempty" tf:"allowed_users,omitempty"`

	AllowedUsersTemplate *bool `json:"allowedUsersTemplate,omitempty" tf:"allowed_users_template,omitempty"`

	Backend *string `json:"backend,omitempty" tf:"backend,omitempty"`

	CidrList *string `json:"cidrList,omitempty" tf:"cidr_list,omitempty"`

	DefaultCriticalOptions map[string]*string `json:"defaultCriticalOptions,omitempty" tf:"default_critical_options,omitempty"`

	DefaultExtensions map[string]*string `json:"defaultExtensions,omitempty" tf:"default_extensions,omitempty"`

	DefaultUser *string `json:"defaultUser,omitempty" tf:"default_user,omitempty"`

	DefaultUserTemplate *bool `json:"defaultUserTemplate,omitempty" tf:"default_user_template,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	KeyIDFormat *string `json:"keyIdFormat,omitempty" tf:"key_id_format,omitempty"`

	KeyType *string `json:"keyType,omitempty" tf:"key_type,omitempty"`

	MaxTTL *string `json:"maxTtl,omitempty" tf:"max_ttl,omitempty"`

	// Unique name for the role.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Target namespace. (requires Enterprise)
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	TTL *string `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type SecretBackendRoleParameters struct {

	// +kubebuilder:validation:Optional
	AlgorithmSigner *string `json:"algorithmSigner,omitempty" tf:"algorithm_signer,omitempty"`

	// +kubebuilder:validation:Optional
	AllowBareDomains *bool `json:"allowBareDomains,omitempty" tf:"allow_bare_domains,omitempty"`

	// +kubebuilder:validation:Optional
	AllowHostCertificates *bool `json:"allowHostCertificates,omitempty" tf:"allow_host_certificates,omitempty"`

	// +kubebuilder:validation:Optional
	AllowSubdomains *bool `json:"allowSubdomains,omitempty" tf:"allow_subdomains,omitempty"`

	// +kubebuilder:validation:Optional
	AllowUserCertificates *bool `json:"allowUserCertificates,omitempty" tf:"allow_user_certificates,omitempty"`

	// +kubebuilder:validation:Optional
	AllowUserKeyIds *bool `json:"allowUserKeyIds,omitempty" tf:"allow_user_key_ids,omitempty"`

	// +kubebuilder:validation:Optional
	AllowedCriticalOptions *string `json:"allowedCriticalOptions,omitempty" tf:"allowed_critical_options,omitempty"`

	// +kubebuilder:validation:Optional
	AllowedDomains *string `json:"allowedDomains,omitempty" tf:"allowed_domains,omitempty"`

	// +kubebuilder:validation:Optional
	AllowedExtensions *string `json:"allowedExtensions,omitempty" tf:"allowed_extensions,omitempty"`

	// Set of allowed public key types and their relevant configuration
	// +kubebuilder:validation:Optional
	AllowedUserKeyConfig []AllowedUserKeyConfigParameters `json:"allowedUserKeyConfig,omitempty" tf:"allowed_user_key_config,omitempty"`

	// +kubebuilder:validation:Optional
	AllowedUserKeyLengths map[string]*float64 `json:"allowedUserKeyLengths,omitempty" tf:"allowed_user_key_lengths,omitempty"`

	// +kubebuilder:validation:Optional
	AllowedUsers *string `json:"allowedUsers,omitempty" tf:"allowed_users,omitempty"`

	// +kubebuilder:validation:Optional
	AllowedUsersTemplate *bool `json:"allowedUsersTemplate,omitempty" tf:"allowed_users_template,omitempty"`

	// +kubebuilder:validation:Optional
	Backend *string `json:"backend,omitempty" tf:"backend,omitempty"`

	// +kubebuilder:validation:Optional
	CidrList *string `json:"cidrList,omitempty" tf:"cidr_list,omitempty"`

	// +kubebuilder:validation:Optional
	DefaultCriticalOptions map[string]*string `json:"defaultCriticalOptions,omitempty" tf:"default_critical_options,omitempty"`

	// +kubebuilder:validation:Optional
	DefaultExtensions map[string]*string `json:"defaultExtensions,omitempty" tf:"default_extensions,omitempty"`

	// +kubebuilder:validation:Optional
	DefaultUser *string `json:"defaultUser,omitempty" tf:"default_user,omitempty"`

	// +kubebuilder:validation:Optional
	DefaultUserTemplate *bool `json:"defaultUserTemplate,omitempty" tf:"default_user_template,omitempty"`

	// +kubebuilder:validation:Optional
	KeyIDFormat *string `json:"keyIdFormat,omitempty" tf:"key_id_format,omitempty"`

	// +kubebuilder:validation:Optional
	KeyType *string `json:"keyType,omitempty" tf:"key_type,omitempty"`

	// +kubebuilder:validation:Optional
	MaxTTL *string `json:"maxTtl,omitempty" tf:"max_ttl,omitempty"`

	// Unique name for the role.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Target namespace. (requires Enterprise)
	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// +kubebuilder:validation:Optional
	TTL *string `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

// SecretBackendRoleSpec defines the desired state of SecretBackendRole
type SecretBackendRoleSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     SecretBackendRoleParameters `json:"forProvider"`
}

// SecretBackendRoleStatus defines the observed state of SecretBackendRole.
type SecretBackendRoleStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        SecretBackendRoleObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// SecretBackendRole is the Schema for the SecretBackendRoles API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,vault}
type SecretBackendRole struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.backend)",message="backend is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.keyType)",message="keyType is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.name)",message="name is a required parameter"
	Spec   SecretBackendRoleSpec   `json:"spec"`
	Status SecretBackendRoleStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// SecretBackendRoleList contains a list of SecretBackendRoles
type SecretBackendRoleList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []SecretBackendRole `json:"items"`
}

// Repository type metadata.
var (
	SecretBackendRole_Kind             = "SecretBackendRole"
	SecretBackendRole_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: SecretBackendRole_Kind}.String()
	SecretBackendRole_KindAPIVersion   = SecretBackendRole_Kind + "." + CRDGroupVersion.String()
	SecretBackendRole_GroupVersionKind = CRDGroupVersion.WithKind(SecretBackendRole_Kind)
)

func init() {
	SchemeBuilder.Register(&SecretBackendRole{}, &SecretBackendRoleList{})
}
